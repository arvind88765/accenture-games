<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hidden Maze Challenge ‚Äî 3√ó3 Practice</title>
<style>
  :root {
    --bg: #f3f4f6;
    --panel: #ffffff;
    --accent: #111827;
  }
  * { box-sizing: border-box; }

  body {
    margin: 0;
    background: var(--bg);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
  }

  .app {
    width: 780px;
    max-width: 95vw;
    background: var(--panel);
    border-radius: 16px;
    padding: 20px 22px 22px;
    box-shadow: 0 14px 40px rgba(15,23,42,0.15);
  }
  .header {
    font-size: 22px;
    font-weight: 700;
    text-align: center;
    margin-bottom: 14px;
  }

  .instructions-box {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 16px 18px;
    line-height: 1.48;
  }
  .instructions-box h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 17px;
  }
  .instructions-box ul {
    margin: 0;
    padding-left: 18px;
    color: #374151;
  }
  .instructions-box li {
    margin-bottom: 8px;
    font-size: 14px;
  }

  .btn {
    padding: 10px 14px;
    background: #111827;
    color: white;
    border: none;
    border-radius: 999px;
    cursor: pointer;
    font-weight: 600;
    width: 100%;
    margin-top: 12px;
    font-size: 14px;
  }
  .btn:hover {
    background: #020617;
  }
  .btn-red {
    background: #b91c1c;
  }
  .btn-red:hover {
    background: #991b1b;
  }

  .hidden { display: none !important; }

  .timer {
    font-size: 24px;
    font-weight: 700;
    text-align: center;
    margin-bottom: 12px;
  }

  .grid {
    width: 280px;
    height: 280px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    margin: 0 auto 10px auto;
    background: #fff;
    border: 2px solid #d1d5db;
  }

  .cell {
    border: 1px solid #d1d5db;
    background: #ffffff;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    transition: background .18s, transform .14s;
  }

  /* visited path cells (trail) */
  .cell.path {
    background: #222 !important;
  }

  /* player cell */
  .player-cell {
    background: #000 !important;
  }

  /* PERSON ICON */
  .player-icon {
    width: 30px;
    height: 30px;
  }

  /* Key & Door */
  .key {
    font-size: 24px;
    color: #000;
  }
  .door {
    width: 26px;
    height: 38px;
    border: 3px solid #000;
    border-radius: 3px;
    position: relative;
  }
  .door::after {
    content: "";
    width: 6px;
    height: 6px;
    background: #000;
    border-radius: 50%;
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
  }

  /* wall-hit red flash */
  .hit {
    animation: hitAnim .25s;
    background: #fecaca !important;
  }
  @keyframes hitAnim {
    0% { background: #fca5a5; }
    100% { background: #fecaca; }
  }

  .shake {
    animation: shakeAnim .4s;
  }
  @keyframes shakeAnim {
    0%,100% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    75% { transform: translateX(4px); }
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 14px;
    font-size: 14px;
  }
  th, td {
    border: 1px solid #e5e7eb;
    padding: 8px;
    text-align: center;
  }
  th {
    background: #f3f4f6;
  }

  /* Toast popup */
  .toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #111827;
    color: #fff;
    padding: 10px 18px;
    border-radius: 8px;
    font-size: 14px;
    opacity: 0;
    pointer-events: none;
    transition: opacity .25s ease;
    z-index: 9999;
  }
  .toast.show {
    opacity: 1;
  }
</style>
</head>

<body>

<!-- Toast message -->
<div id="toast" class="toast"></div>

<div class="app">

  <div class="header">Hidden Maze Challenge ‚Äî 3√ó3 Practice</div>

  <div id="intro" class="instructions-box">
    <h3>How to Play</h3>
    <ul>
      <li>3√ó3 hidden maze with invisible walls</li>
      <li>Move using mouse or Arrow keys (W/A/S/D)</li>
      <li>Collect all keys inside the maze</li>
      <li>The door unlocks only after collecting all keys</li>
      <li>Hitting a hidden wall flashes red and resets you</li>
      <li>Your travelled path turns dark so you can track it</li>
      <li>You have 3 minutes per round</li>
    </ul>
    <button id="letsStart" class="btn">Start Practice</button>
  </div>

  <div id="game" class="hidden">
    <div id="timer" class="timer">3:00</div>
    <div id="grid" class="grid"></div>
    <p style="text-align:center;">
      Collect <b id="keysLabel">1 KEY</b> then get to the <b>DOOR</b>
    </p>
    <button id="stopSubmit" class="btn btn-red">Stop / Submit</button>
  </div>

  <div id="summary" class="hidden">
    <h3>Session Summary</h3>
    <table>
      <thead>
        <tr><th>Round</th><th>Time</th><th>Moves</th><th>Keys</th></tr>
      </thead>
      <tbody id="summaryTable"></tbody>
    </table>
    <button id="closeSummary" class="btn">Close</button>
  </div>

</div>

<script>
const ROWS = 3, COLS = 3;
let round = 0;
let player = {r:1,c:1};
let startPos = {r:1,c:1};
let door = {r:2,c:2};
let keys = [], originalKeys = [];
let keysNeeded = 1, keysCollected = 0;
let moves = 0, running = false;
let roundSeconds = 180, roundTimer = null;
let roundStartTime = 0;
let cells = [];
let sessionResults = [];

const introEl = document.getElementById("intro");
const gameEl = document.getElementById("game");
const summaryEl = document.getElementById("summary");
const gridEl = document.getElementById("grid");
const timerEl = document.getElementById("timer");
const summaryTable = document.getElementById("summaryTable");
const keysLabelEl = document.getElementById("keysLabel");

const letsStartBtn = document.getElementById("letsStart");
const stopSubmitBtn = document.getElementById("stopSubmit");
const closeSummaryBtn = document.getElementById("closeSummary");

function idx(r,c){ return r*COLS + c; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function formatTime(s){ const m=Math.floor(s/60), ss=s%60; return `${m}:${ss<10?"0"+ss:ss}`; }

/* Toast helper */
function showToast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1200);
}

/* MAZE GENERATOR */
function generatePerfectMaze(){
  const base = Array.from({length:9}, ()=>({u:true,r:true,d:true,l:true}));
  const visited = Array(9).fill(false);
  const stack = [[startPos.r,startPos.c]];
  visited[idx(startPos.r,startPos.c)] = true;

  while(stack.length){
    const [r,c] = stack[stack.length-1];
    const dirs = [[r-1,c,'u'],[r,c+1,'r'],[r+1,c,'d'],[r,c-1,'l']];
    const nbr = dirs.filter(([nr,nc]) => nr>=0&&nr<3&&nc>=0&&nc<3 && !visited[idx(nr,nc)]);
    if(!nbr.length){ stack.pop(); continue; }
    const [nr,nc,dir] = nbr[Math.floor(Math.random()*nbr.length)];
    if(dir==='u'){ base[idx(r,c)].u=false; base[idx(nr,nc)].d=false; }
    if(dir==='r'){ base[idx(r,c)].r=false; base[idx(nr,nc)].l=false; }
    if(dir==='d'){ base[idx(r,c)].d=false; base[idx(nr,nc)].u=false; }
    if(dir==='l'){ base[idx(r,c)].l=false; base[idx(nr,nc)].r=false; }
    visited[idx(nr,nc)] = true;
    stack.push([nr,nc]);
  }
  return base;
}

function buildGrid(){
  gridEl.innerHTML = "";
  const maze = generatePerfectMaze();
  cells = [];
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const d = document.createElement("div");
      d.className = "cell";
      d.onclick = ()=>onCellClick(r,c);
      gridEl.appendChild(d);
      cells.push({r,c,walls:maze[idx(r,c)]});
    }
  }
}

/* REACHABLE CELLS (for key placement) */
function getReachableAvoidingDoor(){
  const q = [[startPos.r,startPos.c]];
  const seen = Array(9).fill(false);
  seen[idx(startPos.r,startPos.c)] = true;
  const out = [];
  while(q.length){
    const [r,c] = q.shift();
    out.push({r,c});
    const w = cells[idx(r,c)].walls;
    const nbr = [];
    if(!w.u) nbr.push([r-1,c]);
    if(!w.r) nbr.push([r,c+1]);
    if(!w.d) nbr.push([r+1,c]);
    if(!w.l) nbr.push([r,c-1]);
    for(const [nr,nc] of nbr){
      if(nr<0||nr>=3||nc<0||nc>=3) continue;
      if(nr===door.r && nc===door.c) continue;
      if(!seen[idx(nr,nc)]){
        seen[idx(nr,nc)] = true;
        q.push([nr,nc]);
      }
    }
  }
  return out;
}

/* KEYS */
function placeKeysRandom(){
  keys = []; originalKeys = []; keysCollected = 0;
  let desired = Math.random()<0.65 ? 1 : 2;
  let attempts = 0;
  let reachable = [];
  while(attempts<20){
    reachable = getReachableAvoidingDoor()
      .filter(c => !(c.r===startPos.r && c.c===startPos.c) && !(c.r===door.r && c.c===door.c));
    if(reachable.length>=desired) break;
    buildGrid(); placeEntities();
    attempts++;
  }
  if(reachable.length<desired) desired = Math.max(1, reachable.length);
  keysNeeded = desired;
  shuffle(reachable);
  for(let i=0;i<keysNeeded;i++){
    keys.push({...reachable[i]});
    originalKeys.push({...reachable[i]});
  }
  keysLabelEl.textContent = keysNeeded===1 ? "1 KEY" : keysNeeded + " KEYS";
}

/* PLAYER / DOOR POSITIONS */
function placeEntities(){
  startPos = {r:1,c:1};
  player   = {r:1,c:1};
  door     = {r:2,c:2};
}

/* PATH TRACKING HELPERS */
function markPath(r,c){
  gridEl.children[idx(r,c)].classList.add("path");
}
function clearPath(){
  document.querySelectorAll(".cell.path").forEach(el=>el.classList.remove("path"));
}

/* RENDER */
function render(){
  const all = document.querySelectorAll(".cell");
  all.forEach(el => { el.innerHTML = ""; el.classList.remove("hit","player-cell"); });

  // keys
  keys.forEach(k => {
    const keyCell = gridEl.children[idx(k.r,k.c)];
    keyCell.innerHTML = '<div class="key">üóùÔ∏è</div>';
  });

  // door
  const doorCell = gridEl.children[idx(door.r,door.c)];
  doorCell.innerHTML = '<div class="door"></div>';

  // player
  const pCell = gridEl.children[idx(player.r,player.c)];
  pCell.classList.add("player-cell");
  pCell.innerHTML = `
    <svg class="player-icon" viewBox="0 0 24 24" fill="white">
      <circle cx="12" cy="7" r="4"></circle>
      <path d="M4 20c0-4 4-6 8-6s8 2 8 6" stroke="white" stroke-width="2" fill="none"/>
    </svg>
  `;
}

/* MOVEMENT */
function onCellClick(r,c){
  if(!running) return;
  if(Math.abs(r-player.r)+Math.abs(c-player.c)!==1) return;
  attemptMove(r,c);
}

function attemptMove(tr, tc) {
  let dr = tr - player.r, dc = tc - player.c;
  let dir = null;
  if (dr === -1) dir = 'u';
  if (dr === 1) dir = 'd';
  if (dc === -1) dir = 'l';
  if (dc === 1) dir = 'r';

  // touching DOOR without enough keys
  if (tr === door.r && tc === door.c && keysCollected < keysNeeded) {
    if (keysNeeded === 1) {
      showToast("Collect the key and come to the door");
    } else {
      showToast(`Collect ${keysNeeded} keys and come to the door`);
    }

    gridEl.children[idx(tr, tc)].classList.add("hit");
    gridEl.classList.add("shake");
    setTimeout(() => gridEl.classList.remove("shake"), 300);
    return;
  }

  const cur = cells[idx(player.r, player.c)];

  // WALL HIT ‚Üí instant reset to start
  if (cur.walls[dir]) {
    const pCell = gridEl.children[idx(player.r, player.c)];
    pCell.classList.add("hit");
    gridEl.classList.add("shake");
    setTimeout(() => gridEl.classList.remove("shake"), 250);

    // RESET STATE IMMEDIATELY
    player = { ...startPos };
    keys = originalKeys.map(k => ({ ...k }));
    keysCollected = 0;
    moves = 0;
    clearPath();
    render();
    return;
  }

  // SUCCESSFUL MOVE
  markPath(player.r, player.c);
  player = { r: tr, c: tc };
  moves++;

  // collect key
  const fi = keys.findIndex(k => k.r === player.r && k.c === player.c);
  if (fi !== -1) {
    keys.splice(fi, 1);
    keysCollected++;
  }

  render();

  // win condition
  if (keysCollected >= keysNeeded && player.r === door.r && player.c === door.c) {
    endRound(true);
  }
}

window.onkeydown = e => {
  if(!running) return;
  let r = player.r, c = player.c;
  if(e.key==='ArrowUp' || e.key==='w' || e.key==='W') r--;
  if(e.key==='ArrowDown' || e.key==='s' || e.key==='S') r++;
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') c--;
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') c++;
  if(r>=0 && r<3 && c>=0 && c<3) attemptMove(r,c);
};

/* ROUND CONTROL */
function startRound(){
  round++;
  buildGrid();
  placeEntities();
  placeKeysRandom();
  moves = 0;
  keysCollected = 0;
  clearPath();
  render();

  running = true;
  roundSeconds = 180;
  timerEl.textContent = formatTime(roundSeconds);
  roundStartTime = Date.now();

  clearInterval(roundTimer);
  roundTimer = setInterval(()=>{
    roundSeconds--;
    timerEl.textContent = formatTime(roundSeconds);
    if(roundSeconds <= 0) endRound(false);
  },1000);

  introEl.classList.add("hidden");
  summaryEl.classList.add("hidden");
  gameEl.classList.remove("hidden");
}

function endRound(solved){
  running=false;
  clearInterval(roundTimer);
  const t = Math.floor((Date.now() - roundStartTime)/1000);
  sessionResults.push({round, time: t, moves, keys: keysCollected, solved});
  setTimeout(()=>startRound(),300);
}

/* SUMMARY */
stopSubmitBtn.onclick = ()=>{
  if(running){
    running=false;
    clearInterval(roundTimer);
    const t = Math.floor((Date.now() - roundStartTime)/1000);
    sessionResults.push({round, time: t, moves, keys: keysCollected, solved:false});
  }
  showSummary();
};

function showSummary(){
  gameEl.classList.add("hidden");
  summaryEl.classList.remove("hidden");
  summaryTable.innerHTML = "";
  sessionResults.forEach(r=>{
    summaryTable.innerHTML += `<tr>
      <td>${r.round}</td>
      <td>${Math.floor(r.time/60)}m ${r.time%60}s</td>
      <td>${r.moves}</td>
      <td>${r.keys}</td>
    </tr>`;
  });
}

closeSummaryBtn.onclick = ()=>{
  summaryEl.classList.add("hidden");
  introEl.classList.remove("hidden");
};

letsStartBtn.onclick = startRound;

</script>
<script defer src="/_vercel/insights/script.js"></script>
</body>
</html>

