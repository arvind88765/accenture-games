<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hidden Maze Challenge â€” 3Ã—3 Practice</title>

<style>
  :root{
    --bg:#f3f5f7;
    --panel:#ffffff;
    --muted:#6b7280;
    --accent:#0f1724;
    --tile:#f8fafc;
    --player:#0b2948;
    --path:#d7ecff;
  }
  body{
    margin:0;
    font-family:Inter,system-ui,Arial;
    background:var(--bg);
    color:var(--accent);
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:100vh;
  }
  .app{
    width:760px;
    background:var(--panel);
    border-radius:12px;
    padding:20px;
    box-shadow:0 12px 38px rgba(0,0,0,0.08);
  }
  .header{
    font-size:22px;
    font-weight:700;
    text-align:center;
    margin-bottom:14px;
  }

  /* Instructions Panel */
  .instructions-box{
    background:#fbfdff;
    border:1px solid #e5e9ef;
    border-radius:10px;
    padding:16px;
    line-height:1.48;
  }
  .instructions-box h3{
    margin-top:0;
    margin-bottom:10px;
    font-size:17px;
  }
  .instructions-box ul{
    margin:0;
    padding-left:18px;
    color:#374151;
  }
  .instructions-box li{
    margin-bottom:8px;
    font-size:14px;
  }

  .btn{
    padding:10px 14px;
    background:#0f1724;
    color:white;
    border:none;
    border-radius:10px;
    cursor:pointer;
    font-weight:700;
    width:100%;
    margin-top:12px;
  }

  /* Game Area */
  .hidden{display:none !important;}

  .timer{
    font-size:24px;
    font-weight:700;
    text-align:center;
    margin-bottom:12px;
  }

  .grid{
    width:260px;
    background:#fff;
    border-radius:12px;
    border:1px solid #e6edf3;
    padding:12px;
    display:grid;
    grid-template-columns: repeat(3, 1fr); /* <<< FIX: 3Ã—3 grid layout */
    gap:8px;
    margin:0 auto;
  }

  .cell{
    width:72px;
    height:72px;
    background:var(--tile);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition:background .18s,transform .14s;
  }
  .cell.path{
    background:var(--path);
    box-shadow:0 0 14px 5px rgba(0,130,255,0.25);
  }
  .player{
    width:58px;height:58px;background:var(--player);border-radius:6px;
    display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;
  }
  .key{font-size:22px}
  .door{font-size:26px}

  .cell.hit{animation:hit .28s;background:#ffe0e0}
  @keyframes hit{0%{transform:scale(1.08);background:#ffcccc;}100%{transform:none}}

  .shake{animation:shakeAnim .45s}
  @keyframes shakeAnim{
    0%{transform:translateX(0)}
    20%{transform:translateX(-4px)}
    40%{transform:translateX(4px)}
    60%{transform:translateX(-3px)}
    80%{transform:translateX(3px)}
    100%{transform:translateX(0)}
  }

  .controls{
    text-align:center;
    margin-top:14px;
  }
  .btn-red{
    background:#b91c1c;
  }

  /* Summary */
  table{
    width:100%;
    border-collapse:collapse;
    margin-top:14px;
  }
  th,td{
    border:1px solid #e6edf3;
    padding:8px;
    text-align:center;
  }
  th{
    background:#f1f5f9;
    color:#374151;
    font-weight:600;
  }
</style>
</head>

<body>
<div class="app">

  <div class="header">Hidden Maze Challenge â€” 3Ã—3 Practice</div>

  <!-- INSTRUCTIONS SCREEN -->
  <div id="intro" class="instructions-box">
    <h3>How to Play</h3>
    <ul>
      <li>This is a 3Ã—3 hidden maze with invisible walls.</li>
      <li>Move using your mouse or Arrow keys (W/A/S/D).</li>
      <li>Collect all keys shown inside the maze.</li>
      <li>The door will unlock only after collecting all keys.</li>
      <li>Hitting an invisible wall sends you back to the start and resets keys.</li>
      <li>Your travelled path glows so you can track where youâ€™ve been.</li>
      <li>You have 3 minutes per round. New rounds start automatically.</li>
    </ul>
    <button id="letsStart" class="btn">Start Practice</button>
  </div>

  <!-- GAME SCREEN -->
  <div id="game" class="hidden">
    <div id="timer" class="timer">3:00</div>
    <div id="grid" class="grid"></div>

    <div class="controls">
      <button id="stopSubmit" class="btn btn-red">Stop / Submit</button>
    </div>
  </div>

  <!-- SUMMARY SCREEN -->
  <div id="summary" class="hidden">
    <h3>Session Summary</h3>
    <table id="summaryTable">
      <thead>
        <tr><th>Round</th><th>Time Taken</th><th>Moves</th><th>Keys</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <button id="closeSummary" class="btn" style="margin-top:12px">Close</button>
  </div>

</div>

<script>
/* ------------------------
   GAME LOGIC  (unchanged)
------------------------ */

const ROWS = 3, COLS = 3;
let round = 0;
let player = {r:1,c:1};
let startPos = {r:1,c:1};
let door = {r:2,c:2};
let keys=[], originalKeys=[];
let keysNeeded=1, keysCollected=0;
let moves=0, running=false;
let roundSeconds=180, roundTimer=null;
let roundStartTime=0;
let cells=[];
let sessionResults=[];

const introEl=document.getElementById("intro");
const gameEl=document.getElementById("game");
const summaryEl=document.getElementById("summary");
const summaryTableBody=document.querySelector("#summaryTable tbody");
const timerEl=document.getElementById("timer");
const gridEl=document.getElementById("grid");

const letsStartBtn=document.getElementById("letsStart");
const stopSubmitBtn=document.getElementById("stopSubmit");
const closeSummaryBtn=document.getElementById("closeSummary");

function idx(r,c){return r*COLS+c}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}}
function formatTime(s){const m=Math.floor(s/60);const ss=s%60;return `${m}:${ss<10?"0"+ss:ss}`}

/* ------------- MAZE GENERATOR ------------- */
function generatePerfectMaze(){
  const base=Array.from({length:9},()=>({u:true,r:true,d:true,l:true}));
  const visited=Array(9).fill(false);
  const stack=[[startPos.r,startPos.c]];
  visited[idx(startPos.r,startPos.c)]=true;

  while(stack.length){
    const [r,c]=stack[stack.length-1];
    const dirs=[[r-1,c,'u'],[r,c+1,'r'],[r+1,c,'d'],[r,c-1,'l']];
    const nbrs=dirs.filter(([nr,nc])=>nr>=0&&nr<3&&nc>=0&&nc<3 && !visited[idx(nr,nc)]);
    if(!nbrs.length){stack.pop();continue;}
    const [nr,nc,dir]=nbrs[Math.floor(Math.random()*nbrs.length)];
    if(dir==='u'){base[idx(r,c)].u=false;base[idx(nr,nc)].d=false;}
    if(dir==='r'){base[idx(r,c)].r=false;base[idx(nr,nc)].l=false;}
    if(dir==='d'){base[idx(r,c)].d=false;base[idx(nr,nc)].u=false;}
    if(dir==='l'){base[idx(r,c)].l=false;base[idx(nr,nc)].r=false;}
    visited[idx(nr,nc)]=true;
    stack.push([nr,nc]);
  }
  return base;
}

function buildGrid(){
  gridEl.innerHTML="";
  const maze=generatePerfectMaze();
  cells=[];
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      let d=document.createElement("div");
      d.className="cell";
      d.onclick=()=>onCellClick(r,c);
      gridEl.appendChild(d);
      cells.push({r,c,walls:maze[idx(r,c)]});
    }
  }
}

/* BFS safe reachable */
function getReachableAvoidingDoor(){
  const q=[[startPos.r,startPos.c]];
  const seen=Array(9).fill(false);
  seen[idx(startPos.r,startPos.c)]=true;
  const out=[];
  while(q.length){
    const [r,c]=q.shift();
    out.push({r,c});
    const w=cells[idx(r,c)].walls;
    const nbrs=[];
    if(!w.u)nbrs.push([r-1,c]);
    if(!w.r)nbrs.push([r,c+1]);
    if(!w.d)nbrs.push([r+1,c]);
    if(!w.l)nbrs.push([r,c-1]);
    for(const[nr,nc] of nbrs){
      if(nr<0||nr>=3||nc<0||nc>=3)continue;
      if(nr===door.r&&nc===door.c)continue;
      if(!seen[idx(nr,nc)]){
        seen[idx(nr,nc)]=true;
        q.push([nr,nc]);
      }
    }
  }
  return out;
}

/* KEY PLACEMENT */
function placeKeysRandom(){
  keys=[];originalKeys=[];keysCollected=0;
  let desired=Math.random()<0.65?1:2;
  let attempts=0; let reachable=[];
  while(attempts<20){
    reachable=getReachableAvoidingDoor()
      .filter(c=>!(c.r===startPos.r&&c.c===startPos.c)&&!(c.r===door.r&&c.c===door.c));
    if(reachable.length>=desired)break;
    buildGrid();placeEntities();
    attempts++;
  }
  if(reachable.length<desired)desired=Math.max(1,reachable.length);
  keysNeeded=desired;
  shuffle(reachable);
  for(let i=0;i<keysNeeded;i++){
    keys.push({...reachable[i]});
    originalKeys.push({...reachable[i]});
  }
}

/* Entities */
function placeEntities(){
  startPos={r:1,c:1};
  player={r:1,c:1};
  door={r:2,c:2};
}

/* Render */
function render(){
  const all=document.querySelectorAll(".cell");
  all.forEach(el=>{el.innerHTML="";el.classList.remove("hit")});
  keys.forEach(k=>{
    gridEl.children[idx(k.r,k.c)].innerHTML='<div class="key">ðŸ”‘</div>';
  });
  gridEl.children[idx(door.r,door.c)].innerHTML='<div class="door">ðŸšª</div>';
  gridEl.children[idx(player.r,player.c)].innerHTML='<div class="player">ðŸ™‚</div>';
}

/* Path */
function markPath(r,c){gridEl.children[idx(r,c)].classList.add("path")}
function clearPath(){document.querySelectorAll(".path").forEach(el=>el.classList.remove("path"))}

/* Movement */
function onCellClick(r,c){
  if(!running)return;
  if(Math.abs(r-player.r)+Math.abs(c-player.c)!==1)return;
  attemptMove(r,c);
}

function attemptMove(tr,tc){
  let dr=tr-player.r,dc=tc-player.c;
  let dir=null;
  if(dr==-1)dir='u';
  if(dr==1)dir='d';
  if(dc==-1)dir='l';
  if(dc==1)dir='r';

  /* Door block */
  if(tr===door.r&&tc===door.c&&keysCollected<keysNeeded){
    let el=gridEl.children[idx(tr,tc)];
    el.classList.add("hit");setTimeout(()=>el.classList.remove("hit"),300);
    gridEl.classList.add("shake");setTimeout(()=>gridEl.classList.remove("shake"),400);
    return;
  }

  const cur=cells[idx(player.r,player.c)];
  if(cur.walls[dir]){
    let el=gridEl.children[idx(tr,tc)];
    el.classList.add("hit");setTimeout(()=>el.classList.remove("hit"),300);
    gridEl.classList.add("shake");setTimeout(()=>gridEl.classList.remove("shake"),400);

    keys=originalKeys.map(x=>({...x}));
    keysCollected=0;
    clearPath();
    player={...startPos};
    moves=0;
    render();
    return;
  }

  markPath(player.r,player.c);
  player={r:tr,c:tc};
  markPath(player.r,player.c);
  moves++;

  const f=keys.findIndex(k=>k.r===player.r&&k.c===player.c);
  if(f!=-1){keys.splice(f,1);keysCollected++;}

  render();

  if(keysCollected>=keysNeeded&&player.r===door.r&&player.c===door.c)endRound(true);
}

window.onkeydown=(e)=>{
  if(!running)return;
  let r=player.r,c=player.c;
  if(e.key==='ArrowUp'||e.key==='w')r--;
  if(e.key==='ArrowDown'||e.key==='s')r++;
  if(e.key==='ArrowLeft'||e.key==='a')c--;
  if(e.key==='ArrowRight'||e.key==='d')c++;
  if(r>=0&&r<3&&c>=0&&c<3)attemptMove(r,c);
};

/* Round control */
function startRound(){
  round++;
  buildGrid();
  placeEntities();
  placeKeysRandom();
  moves=0;keysCollected=0;
  clearPath();
  render();

  running=true;
  roundStartTime=Date.now();
  roundSeconds=180;
  timerEl.textContent=formatTime(roundSeconds);

  clearInterval(roundTimer);
  roundTimer=setInterval(()=>{
    roundSeconds--;
    timerEl.textContent=formatTime(roundSeconds);
    if(roundSeconds<=0)endRound(false);
  },1000);

  introEl.classList.add("hidden");
  summaryEl.classList.add("hidden");
  gameEl.classList.remove("hidden");
}

function endRound(solved){
  clearInterval(roundTimer);running=false;
  const timeTaken=Math.floor((Date.now()-roundStartTime)/1000);
  sessionResults.push({round,timeTaken,moves,keys:keysCollected,solved});
  setTimeout(()=>startRound(),300);
}

/* Stop & Summary */
stopSubmitBtn.onclick=()=>{
  if(running){
    clearInterval(roundTimer);
    running=false;
    const timeTaken=Math.floor((Date.now()-roundStartTime)/1000);
    sessionResults.push({round,timeTaken,moves,keys:keysCollected,solved:false});
  }
  showSummary();
};

function showSummary(){
  gameEl.classList.add("hidden");
  summaryEl.classList.remove("hidden");
  summaryTableBody.innerHTML="";

  for(const r of sessionResults){
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${r.round}</td>
      <td>${Math.floor(r.timeTaken/60)}m ${r.timeTaken%60}s</td>
      <td>${r.moves}</td>
      <td>${r.keys}</td>`;
    summaryTableBody.appendChild(tr);
  }
}

closeSummaryBtn.onclick=()=>{
  summaryEl.classList.add("hidden");
  introEl.classList.remove("hidden");
};

/* Start */
letsStartBtn.onclick=startRound;

</script>
</body>
</html>
